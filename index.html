<!DOCTYPE html>
<html lang="tr">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    
    <meta name="theme-color" content="#020617">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    
    <title>Renk-Kelime Oyunu</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&family=Orbitron:wght@600;800&display=swap" rel="stylesheet">
    
    <style>
        /* --- CSS STYLES --- */
        
        :root {
            /* Deep Space Background */
            --bg-gradient: radial-gradient(circle at 50% 0%, #1e1b4b 0%, #0f172a 60%, #020617 100%);
            
            /* Glassmorphism Variables */
            --glass-bg: rgba(255, 255, 255, 0.03);
            --glass-border: rgba(255, 255, 255, 0.1);
            --glass-highlight: rgba(255, 255, 255, 0.08);
            
            /* Text Colors */
            --text-main: #ffffff;
            --text-muted: #94a3b8;
            
            /* Gradients & Accents */
            --primary-grad: linear-gradient(90deg, #3b82f6 0%, #6366f1 100%);
            --accent-blue: #3b82f6;
            --accent-red: #ef4444;
            --accent-green: #10b981;
            --accent-yellow: #eab308;
            
            --font-main: 'Inter', system-ui, -apple-system, sans-serif;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            -webkit-tap-highlight-color: transparent;
        }

        html {
            background-color: #020617;
            height: 100%;
        }

        body {
            font-family: var(--font-main);
            background: var(--bg-gradient);
            color: var(--text-main);
            height: 100vh;
            height: 100dvh; 
            width: 100vw;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden; 
            user-select: none;
            -webkit-font-smoothing: antialiased;
        }

        #app {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative;
            z-index: 2; 
        }

        /* Fullscreen Toggle Button */
        #fullscreen-toggle {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 1000;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            width: 44px;
            height: 44px;
            display: none; 
            align-items: center;
            justify-content: center;
            cursor: pointer;
            backdrop-filter: blur(10px);
            transition: all 0.2s;
        }
        
        #fullscreen-toggle:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.1);
        }

        #fullscreen-toggle svg {
            width: 20px;
            height: 20px;
            fill: white;
        }

        /* Screens */
        .screen {
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            width: 100%;
            opacity: 0;
            transition: opacity 0.3s ease-in-out;
        }

        .screen.active {
            display: flex;
            opacity: 1;
        }

        /* --- SHARED GLASS COMPONENT --- */
        .glass-card {
            background: var(--glass-bg);
            backdrop-filter: blur(24px);
            -webkit-backdrop-filter: blur(24px);
            border: 1px solid var(--glass-border);
            padding: 3rem 2.5rem;
            border-radius: 2rem;
            box-shadow: 
                0 25px 50px -12px rgba(0, 0, 0, 0.5),
                inset 0 0 0 1px rgba(255, 255, 255, 0.05);
            max-width: 480px;
            width: 90%;
            text-align: center;
            position: relative;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            max-height: 95%;
            justify-content: center; 
        }

        .glass-card.wide {
            max-width: 800px;
            padding: 2rem;
        }

        .glass-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 1px;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.4), transparent);
        }

        h1 {
            /* ONLY H1 USES ORBITRON */
            font-family: 'Orbitron', sans-serif; 
            font-size: clamp(1.8rem, 5vw, 2.5rem);
            font-weight: 800;
            margin-bottom: 1.5rem;
            color: white;
            line-height: 1.2;
            text-shadow: 0 0 15px rgba(99, 102, 241, 0.6);
            letter-spacing: 2px;
        }

        h2 {
            font-size: 1.8rem;
            font-weight: 700;
            margin-bottom: 1.5rem;
            color: white;
        }
		
		h3 {
            font-size: clamp(1.8rem, 5vw, 2.2rem);
            font-weight: 800;
            margin-bottom: 1.5rem;
            color: white;
            line-height: 1.2;
            text-shadow: 0 4px 12px rgba(0,0,0,0.3);
		}

        p {
            font-size: clamp(0.9rem, 4vw, 1.1rem);
            line-height: 1.5;
            color: var(--text-muted);
            margin-bottom: 0.8rem;
            max-width: 600px;
        }
        
        strong { color: white; font-weight: 600; }

        /* --- INPUTS --- */
        .input-wrapper {
            position: relative;
            margin-bottom: 1.5rem;
            width: 100%;
            max-width: 320px;
        }

        .glow-input {
            width: 100%;
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid var(--glass-border);
            color: white;
            padding: 1rem 1.2rem;
            font-size: 1.1rem;
            border-radius: 12px;
            text-align: center;
            transition: all 0.3s ease;
        }

        .glow-input:focus, .glow-input.filled {
            outline: none;
            border-color: var(--accent-blue);
            box-shadow: 0 0 20px rgba(59, 130, 246, 0.3);
            background: rgba(59, 130, 246, 0.05);
        }

        /* Error Animation for Input */
        @keyframes shakeInput {
            0%, 100% { transform: translateX(0); }
            20%, 60% { transform: translateX(-5px); }
            40%, 80% { transform: translateX(5px); }
        }

        .input-error {
            animation: shakeInput 0.4s cubic-bezier(.36,.07,.19,.97) both;
            border-color: var(--accent-red) !important;
            box-shadow: 0 0 15px rgba(239, 68, 68, 0.4) !important;
        }

        /* --- BUTTONS --- */
        .menu-buttons {
            display: flex;
            flex-direction: column;
            gap: 0.8rem;
            width: 100%;
            max-width: 340px;
        }

        .fancy-btn {
            display: flex;
            align-items: center;
            justify-content: space-between;
            width: 100%;
            padding: 1rem 1.5rem;
            border: none;
            border-radius: 16px;
            color: white;
            font-size: 1.05rem;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s, filter 0.2s;
            position: relative;
            overflow: hidden;
            font-family: var(--font-main);
            background: rgba(255,255,255,0.05);
            border: 1px solid rgba(255,255,255,0.1);
        }
        
        .fancy-btn.stroop { background: linear-gradient(135deg, rgba(59, 130, 246, 0.8), rgba(99, 102, 241, 0.8)); }

        .fancy-btn:hover { transform: translateY(-2px); filter: brightness(1.1); }
        .btn-content { display: flex; align-items: center; gap: 12px; }
        .btn-icon { width: 22px; height: 22px; fill: white; opacity: 0.9; }
        .badge-icon {
            background: rgba(255, 255, 255, 0.2);
            width: 28px; height: 28px; border-radius: 50%;
            display: flex; align-items: center; justify-content: center;
            font-weight: 700; font-size: 0.85rem;
        }
        .badge-icon svg { width: 16px; height: 16px; fill: white; }

        .action-row {
            display: flex;
            gap: 1rem;
            margin-top: 2rem;
            flex-wrap: nowrap;
            justify-content: center;
            width: 100%;
            max-width: 500px;
        }

        .btn-primary {
            background: var(--primary-grad);
            color: white;
            border: none;
            padding: 0.9rem 2rem;
            font-size: 1rem;
            font-weight: 600;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 4px 15px rgba(99, 102, 241, 0.3);
            flex-grow: 1;
        }
        .btn-primary:hover { transform: translateY(-2px); box-shadow: 0 8px 20px rgba(99, 102, 241, 0.4); }

        .btn-secondary {
            background: transparent;
            border: 1px solid rgba(255,255,255,0.2);
            color: var(--text-muted);
            padding: 0.9rem 2rem;
            font-size: 1rem;
            font-weight: 600;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }
        .btn-secondary:hover { background: rgba(255,255,255,0.05); color: white; border-color: rgba(255,255,255,0.5); }
        
        .btn-icon-only {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0.9rem;
            width: 54px; /* Matches height of primary btn */
            flex-shrink: 0;
            background: rgba(255,255,255,0.05);
        }
        
        .btn-icon-only:hover {
            background: rgba(255,255,255,0.1);
            border-color: rgba(255,255,255,0.6);
        }

        .btn-icon-only svg {
            width: 24px;
            height: 24px;
            fill: white;
        }

        /* --- STROOP SPECIFIC --- */
        .key-legend-preview {
            display: flex;
            justify-content: center;
            gap: 1rem;
            margin: 1rem 0;
            flex-wrap: wrap;
            background: rgba(0,0,0,0.2);
            padding: 0.8rem;
            border-radius: 1rem;
            border: 1px solid rgba(255,255,255,0.05);
        }
        
        .key-item { font-size: 0.9rem; color: var(--text-muted); display: flex; align-items: center; gap: 0.5rem; }
        .key-box {
            display: flex; align-items: center; justify-content: center;
            width: 28px; height: 28px;
            border: 1px solid rgba(255,255,255,0.3);
            border-radius: 6px; 
            background: linear-gradient(to bottom, rgba(255,255,255,0.1), rgba(255,255,255,0.05));
            font-weight: 700; color: white; font-family: monospace;
        }

        /* CENTERED STIMULI */
        #fixation { 
            font-size: 4rem; 
            color: rgba(255, 255, 255, 0.3); 
            position: absolute; 
            top: 50%; 
            left: 50%; 
            transform: translate(-50%, -50%); 
        }
        
        #stimulus { 
            font-family: var(--font-main); 
            font-size: clamp(3rem, 10vw, 5rem); 
            font-weight: 800; 
            position: absolute; 
            top: 50%; 
            left: 50%; 
            transform: translate(-50%, -50%); 
            text-shadow: 0 0 30px currentColor; 
            letter-spacing: 0.05em; 
            transition: opacity 0.1s; 
        }

        /* FEEDBACK TEXT */
        #feedback-text {
            font-family: var(--font-main);
            font-size: clamp(2rem, 8vw, 4rem);
            font-weight: 800;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            letter-spacing: 0.05em;
            z-index: 10;
        }

        /* Neutral color (grey/transparent white) */
        .feedback-correct, .feedback-wrong { 
            color: rgba(255, 255, 255, 0.5); 
            text-shadow: none;
        }

        .hidden { visibility: hidden; opacity: 0; }
        
        .color-red { color: #ff5555; }
        .color-green { color: #4ade80; }
        .color-blue { color: #60a5fa; }
        .color-yellow { color: #facc15; }

        #summary-stats {
            width: 100%;
            margin: 1rem 0;
            /* Removed background box for cleaner look */
            text-align: center;
        }
        
        /* Updated Result Styles */
        .result-icon-container {
            margin-bottom: 1.5rem;
            animation: popIn 0.6s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        
        @keyframes popIn {
            0% { transform: scale(0); opacity: 0; }
            100% { transform: scale(1); opacity: 1; }
        }

        .result-message-title {
            color: white;
            font-size: 1.5rem;
            font-weight: 700;
            margin-bottom: 0.5rem;
        }
        
        .result-message-sub {
            color: var(--text-muted);
            font-size: 1.1rem;
        }

        /* Checkmark Animation */
        .checkmark-circle {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background: linear-gradient(135deg, rgba(74, 222, 128, 0.2), rgba(34, 197, 94, 0.1));
            border: 2px solid rgba(74, 222, 128, 0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 0 auto;
            box-shadow: 0 0 30px rgba(74, 222, 128, 0.2);
        }
        
        .checkmark-svg {
            width: 40px;
            height: 40px;
            fill: #4ade80;
        }

    </style>
</head>

<body>
    <div id="app">
        <div id="fullscreen-toggle" title="Tam Ekran Modu">
            <svg id="icon-expand" viewBox="0 0 24 24">
                <path d="M5,5H10V7H7V10H5V5M14,5H19V10H17V7H14V5M17,14H19V19H14V17H17V14M10,17H5V12H7V17H10V17Z" />
            </svg>
        </div>

        <div id="screen-menu" class="screen active">
            <div class="glass-card">
                <h1>Renk-Kelime Oyunu</h1>

                <div class="input-wrapper">
                    <input type="text" id="participant-id" class="glow-input" placeholder="Katılımcı Numarası Giriniz">
                </div>

                <div class="menu-buttons">
                    <button id="btn-stroop" class="fancy-btn stroop">
                        <div class="btn-content">
                            <svg class="btn-icon" viewBox="0 0 24 24"><path d="M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2M12,4A8,8 0 0,1 20,12A8,8 0 0,1 12,20A8,8 0 0,1 4,12A8,8 0 0,1 12,4M12,6A6,6 0 0,0 6,12A6,6 0 0,0 18,12A6,6 0 0,0 12,6M12,8A4,4 0 0,1 16,12A4,4 0 0,1 12,16A4,4 0 0,1 8,12A4,4 0 0,1 12,8Z" /></svg>
                            Başlat
                        </div>
                        <div class="badge-icon">
                            <svg viewBox="0 0 24 24"><path d="M17.5,12A1.5,1.5 0 0,1 16,10.5A1.5,1.5 0 0,1 17.5,9A1.5,1.5 0 0,1 19,10.5A1.5,1.5 0 0,1 17.5,12M14.5,8A1.5,1.5 0 0,1 13,6.5A1.5,1.5 0 0,1 14.5,5A1.5,1.5 0 0,1 16,6.5A1.5,1.5 0 0,1 14.5,8M9.5,8A1.5,1.5 0 0,1 8,6.5A1.5,1.5 0 0,1 9.5,5A1.5,1.5 0 0,1 11,6.5A1.5,1.5 0 0,1 9.5,8M6.5,12A1.5,1.5 0 0,1 5,10.5A1.5,1.5 0 0,1 6.5,9A1.5,1.5 0 0,1 8,10.5A1.5,1.5 0 0,1 6.5,12M12,3A9,9 0 0,0 3,12A9,9 0 0,0 12,21C12.39,21 13.24,20.85 13.5,20.6C13.88,20.21 14,19.92 14,19.5V19A2,2 0 0,0 16,17V16.3C16,15.65 16.39,15.11 17,14.86C19.34,13.9 21,11.63 21,9A9,9 0 0,0 12,3Z" /></svg>
                        </div>
                    </button>
                </div>
            </div>
        </div>

        <div id="screen-stroop-instructions" class="screen">
            <div class="glass-card wide">
                <h3>Renk-Kelime Oyunu</h3>
                <p>Ekranda bazı kelimeler göreceksin ama bu kelimelerin yazı rengi bazen farklı olabilir. Senin görevin çok basit: Kelimenin ne yazdığına değil, <strong>yazı renginin ne olduğuna</strong> bakıp klavyendeki tuşlara basarak yanıt vermek.</p>
                <p>Mümkün olduğunca hızlı ve doğru cevaplamaya çalış.</p>
				<p>Klavyede Kırmızı renkte yazıldıysa <strong>K</strong>, Mavi renkte yazıldıysa <strong>M</strong>, Yeşil renkte yazıldıysa <strong>Y</strong>, Sarı renkte yazıldıysa <strong>S</strong> tuşuna basın.</p>
				<p>Örneğin, kelimede ‘kırmızı’ yazsa bile yazı rengi mavi olabilir. O zaman doğru cevap: <strong>M</strong> tuşuna basmak.</p>
                <p>Hadi şimdi birkaç deneme yapalım. Hazır olduğunda oyunu başlatabilirsin.</p>
                <div class="key-legend-preview">
                    <div class="key-item"><span class="key-box">K</span> KIRMIZI</div>
                    <div class="key-item"><span class="key-box">Y</span> YEŞİL</div>
                    <div class="key-item"><span class="key-box">M</span> MAVİ</div>
                    <div class="key-item"><span class="key-box">S</span> SARI</div>
                </div>
                <div class="action-row">
                    <button id="btn-stroop-start" class="btn-primary">Oyunu Başlat</button>
                    <button class="btn-back btn-secondary">Menüye Dön</button>
                </div>
            </div>
        </div>

        <div id="screen-stroop-task" class="screen">
            <div id="fixation">+</div>
            <div id="stimulus" class="hidden">KELİME</div>
            <div id="feedback-text" class="hidden"></div>
        </div>

        <div id="screen-break" class="screen">
            <div class="glass-card">
                <h2>Alıştırma Tamamlandı</h2>
                <p>Harika gidiyorsun. Şimdi asıl oyun zamanı.</p>
				<p>Asıl oyun sırasında Doğru veya Yanlış yaptığına dair bilgilendirme olmayacak.</p>
                <p>Devam etmeye hazır olduğunda devam et'e tıkla.</p>
                <div class="action-row">
                    <button id="btn-continue-block" class="btn-primary">Devam Et</button>
                </div>
            </div>
        </div>

        <div id="screen-results" class="screen">
            <div class="glass-card wide">
                <div id="summary-stats"></div>
                
                <div class="action-row">
                    <button id="btn-download" class="btn-primary">Sonuçları Gönder</button>
                    </div>
            </div>
        </div>
    </div>

    <script>
        /**
         * ETHEREAL SOUND SYNTHESIZER
         * Muted Gameplay Feedback
         */
        const SoundManager = {
            ctx: null,
            masterGain: null,
            delayNode: null,
            feedbackNode: null,
            enabled: true,

            init() {
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                this.ctx = new AudioContext();

                // 1. Master Volume
                this.masterGain = this.ctx.createGain();
                this.masterGain.gain.value = 0.25;

                // 2. Space Delay (Atmosphere)
                this.delayNode = this.ctx.createDelay();
                this.delayNode.delayTime.value = 0.3; 
                
                this.feedbackNode = this.ctx.createGain();
                this.feedbackNode.gain.value = 0.25; 

                this.delayNode.connect(this.feedbackNode);
                this.feedbackNode.connect(this.delayNode);

                this.delayNode.connect(this.masterGain);
                this.masterGain.connect(this.ctx.destination);

                this.attachListeners();
            },

            resume() {
                if (this.ctx && this.ctx.state === 'suspended') {
                    this.ctx.resume();
                }
            },

            playAmbient() {
                if (!this.enabled || !this.ctx) return;
                this.resume();

                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                const panner = this.ctx.createStereoPanner();

                osc.type = 'sine';
                
                const now = this.ctx.currentTime;
                const freq = Math.random() > 0.5 ? 880 : 987;
                osc.frequency.setValueAtTime(freq, now);
                panner.pan.value = (Math.random() * 0.4) - 0.2;

                gain.gain.setValueAtTime(0, now);
                gain.gain.linearRampToValueAtTime(0.04, now + 0.1); 
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.4);

                osc.connect(panner);
                panner.connect(gain);
                gain.connect(this.masterGain);
                gain.connect(this.delayNode); 

                osc.start(now);
                osc.stop(now + 0.5);
            },

            playClick() {
                if (!this.enabled || !this.ctx) return;
                this.resume();

                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();

                osc.type = 'sine';
                const now = this.ctx.currentTime;

                osc.frequency.setValueAtTime(1046.5, now); // High C

                gain.gain.setValueAtTime(0, now);
                gain.gain.linearRampToValueAtTime(0.15, now + 0.01); 
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.15); 

                osc.connect(gain);
                gain.connect(this.masterGain); // No Delay for clicks

                osc.start(now);
                osc.stop(now + 0.2);
            },

            playError() {
                if (!this.enabled || !this.ctx) return;
                this.resume();

                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();

                osc.type = 'sine';
                const now = this.ctx.currentTime;

                osc.frequency.setValueAtTime(330, now);
                osc.frequency.exponentialRampToValueAtTime(320, now + 0.4);

                gain.gain.setValueAtTime(0, now);
                gain.gain.linearRampToValueAtTime(0.15, now + 0.05); 
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.4);

                osc.connect(gain);
                gain.connect(this.masterGain);
                gain.connect(this.delayNode); 

                osc.start(now);
                osc.stop(now + 0.5);
            },

            attachListeners() {
                // Select generic UI elements for Menu Clicks Only
                const interactables = document.querySelectorAll('button, .fancy-btn, input, #fullscreen-toggle');
                
                interactables.forEach(el => {
                    const triggerClick = () => this.playClick();
                    el.addEventListener('mousedown', triggerClick);
                    el.addEventListener('touchstart', triggerClick, {passive: true});
                });

                // Ambient Click Listener
                const handleGlobalClick = (e) => {
                    const menu = document.getElementById('screen-menu');
                    if (!menu.classList.contains('active')) return;

                    const isUI = e.target.closest('button, input, .fancy-btn, #fullscreen-toggle, .glass-card');
                    
                    if (!isUI) {
                        this.playAmbient();
                    }
                };

                window.addEventListener('mousedown', handleGlobalClick);
                window.addEventListener('touchstart', handleGlobalClick, {passive: true});
            }
        };

        const Utils = {
            shuffle(array) { for (let i = array.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [array[i], array[j]] = [array[j], array[i]]; } return array; },
            downloadJSON(data, filename) {
                if (!data) return;
                const blob = new Blob([JSON.stringify(data, null, 2)], {type: "application/json"});
                const url = URL.createObjectURL(blob);
                const link = document.createElement("a");
                link.setAttribute("href", url);
                link.setAttribute("download", filename);
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            }
        };

        const App = {
            subjectId: '', currentTest: null, currentScreenId: 'screen-menu',

            init() {
                SoundManager.init();

                document.getElementById('btn-stroop').addEventListener('click', () => this.selectTest('stroop'));

                document.querySelectorAll('.btn-back').forEach(btn => { btn.addEventListener('click', () => this.showScreen('screen-menu')); });

                document.getElementById('btn-stroop-start').addEventListener('click', () => StroopTest.start());
                document.getElementById('btn-continue-block').addEventListener('click', () => StroopTest.nextBlock());

                document.getElementById('fullscreen-toggle').addEventListener('click', () => this.toggleFullscreen());
                document.addEventListener('fullscreenchange', () => this.updateFullscreenButtonVisibility());

                document.addEventListener('keydown', (e) => { if (this.currentTest === 'stroop') StroopTest.handleInput(e); });
                
                const idInput = document.getElementById('participant-id');
                idInput.addEventListener('input', (e) => {
                     if(e.target.value.trim().length > 0) e.target.classList.add('filled');
                     else e.target.classList.remove('filled');
                     e.target.classList.remove('input-error');
                });
                
                this.showScreen('screen-menu');
            },

            // --- DATA SENDING FUNCTION ---
            sendToGoogle: function(dataPayload) {
                // *** PASTE YOUR GOOGLE SCRIPT URL HERE ***
                const googleUrl = 'https://script.google.com/macros/s/AKfycbzgPZ0OGnRJVEsR4VBDJUp8EWzIZLxb9jIMJT_0Lx8kgz_ZiceOcLIaRPPl7HDzsXMB/exec';
                
                const btn = document.getElementById('btn-download');
                btn.innerText = "Sunucuya Gönderiliyor...";
                btn.disabled = true;

                fetch(googleUrl, {
                    method: 'POST',
                    mode: 'no-cors',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(dataPayload)
                }).then(() => {
                    btn.innerText = "✔ Başarıyla Gönderildi";
                }).catch(err => {
                    btn.innerText = "Hata!";
                    btn.disabled = false;
                    alert("Veri gönderme hatası. Lütfen öğretmene haber verin.");
                    console.error(err);
                });
            },

            toggleFullscreen() {
                const doc = document.documentElement;
                if (!document.fullscreenElement) { doc.requestFullscreen().catch(err => { console.log(`Error attempting to enable fullscreen: ${err.message}`); }); } 
                else { document.exitFullscreen(); }
            },

            updateFullscreenButtonVisibility() {
                const btn = document.getElementById('fullscreen-toggle');
                const isMenu = this.currentScreenId === 'screen-menu';
                if (isMenu && !document.fullscreenElement) { btn.style.display = 'flex'; } else { btn.style.display = 'none'; }
            },

            selectTest(testId) {
                const idInput = document.getElementById('participant-id');
                const idValue = idInput.value.trim();
                
                if (!idValue) {
                    SoundManager.playError();
                    idInput.classList.remove('input-error');
                    void idInput.offsetWidth; 
                    idInput.classList.add('input-error');
                    idInput.focus();
                    return;
                }
                
                this.subjectId = idValue;
                this.currentTest = testId;

                if (testId === 'stroop') { this.showScreen('screen-stroop-instructions'); } 
            },

            showScreen(screenId) {
                this.currentScreenId = screenId;
                document.querySelectorAll('.screen').forEach(el => el.classList.remove('active'));
                document.getElementById(screenId).classList.add('active');
                
                this.updateFullscreenButtonVisibility();
            },

            showResults(data, summaryHtml) {
                this.showScreen('screen-results');
                document.getElementById('summary-stats').innerHTML = summaryHtml;
            }
        };

        const StroopTest = {
            config: {
                colors: ['red', 'green', 'blue', 'yellow'],
                words: ['KIRMIZI', 'YEŞİL', 'MAVİ', 'SARI'],
                
                keys: { 's': 'yellow', 'y': 'green', 'm': 'blue', 'k': 'red' },

                // Max Stimulus 3000ms
                timing: { fixation: 500, maxStimulus: 3000, isi: 1000, feedbackDuration: 800 },
                // 16 practice, 48 experimental
                trials: { practice: 16, experimental: 48 }
            },
            state: { block: 'practice', trials: [], trialIndex: 0, results: [], waitingForResponse: false, trialStartTime: 0, timeoutIds: [] },

            start() { this.state.block = 'practice'; this.state.results = []; this.runBlock(); },
            nextBlock() { this.state.block = 'experimental'; this.runBlock(); },

            runBlock() {
                const count = this.state.block === 'practice' ? this.config.trials.practice : this.config.trials.experimental;
                this.state.trials = this.generateTrials(count);
                this.state.trialIndex = 0;
                App.showScreen('screen-stroop-task');
                this.startCountdown();
            },

            startCountdown() {
                const elStimulus = document.getElementById('stimulus');
                const elFixation = document.getElementById('fixation');
                const elFeedback = document.getElementById('feedback-text');
                
                elFixation.style.visibility = 'hidden';
                elFeedback.classList.add('hidden');
                
                elStimulus.classList.remove('hidden');
                elStimulus.className = '';
                elStimulus.style.color = 'white';
                elStimulus.style.textShadow = '0 0 30px rgba(255,255,255,0.5)';
                let count = 3;
                elStimulus.textContent = count;
                const countdownInterval = setInterval(() => {
                    count--;
                    if (count > 0) { elStimulus.textContent = count; } else {
                        clearInterval(countdownInterval);
                        elStimulus.classList.add('hidden');
                        this.runTrial();
                    }
                }, 1000);
            },

            generateTrials(count) {
                let trials = [];
                const colors = this.config.colors;
                const words = this.config.words;

                const createTrial = (color, word, condition) => {
                     return { block: this.state.block, trialNum: 0, condition, color, word };
                };

                if (count === 16) { // Practice (Balanced 16 trials)
                    colors.forEach((inkColor, idx) => {
                        for(let k=0; k<2; k++) trials.push(createTrial(inkColor, words[idx], 'congruent'));
                        let availableDistractors = colors.map((c, i) => i).filter(i => i !== idx);
                        Utils.shuffle(availableDistractors);
                        for(let k=0; k<2; k++) {
                            const distIdx = availableDistractors[k];
                            trials.push(createTrial(inkColor, words[distIdx], 'incongruent'));
                        }
                    });

                } else if (count === 48) { // Experimental (Perfectly Balanced)
                    colors.forEach((inkColor, idx) => {
                        for(let i=0; i<6; i++) trials.push(createTrial(inkColor, words[idx], 'congruent'));
                        let otherIndices = [0, 1, 2, 3].filter(i => i !== idx);
                        let distractors = [...otherIndices, ...otherIndices]; 
                        distractors.forEach(dIdx => {
                            trials.push(createTrial(inkColor, words[dIdx], 'incongruent'));
                        });
                    });
                } else {
                     const half = Math.floor(count / 2);
                     for (let i = 0; i < half; i++) {
                        const color = this.config.colors[Math.floor(Math.random() * 4)];
                        const idx = this.config.colors.indexOf(color);
                        trials.push(createTrial(color, words[idx], 'congruent'));
                     }
                     for (let i = 0; i < (count - half); i++) {
                        const color = this.config.colors[Math.floor(Math.random() * 4)];
                        const others = this.config.colors.filter(c => c !== color);
                        const otherColor = others[Math.floor(Math.random() * 3)];
                        const oIdx = this.config.colors.indexOf(otherColor);
                        trials.push(createTrial(color, words[oIdx], 'incongruent'));
                     }
                }

                trials = Utils.shuffle(trials);
                trials.forEach((t, i) => t.trialNum = i + 1);
                return trials;
            },

            runTrial() {
                if (this.state.trialIndex >= this.state.trials.length) {
                    if (this.state.block === 'practice') App.showScreen('screen-break');
                    else this.finish();
                    return;
                }
                const trial = this.state.trials[this.state.trialIndex];
                const elFixation = document.getElementById('fixation');
                const elStimulus = document.getElementById('stimulus');
                const elFeedback = document.getElementById('feedback-text');
                
                elFeedback.classList.add('hidden'); // Ensure feedback is gone
                elFixation.style.visibility = 'visible';
                elStimulus.classList.add('hidden');
                
                this.state.waitingForResponse = false;
                
                this.state.timeoutIds.push(setTimeout(() => {
                    elFixation.style.visibility = 'hidden';
                    elStimulus.textContent = trial.word;
                    elStimulus.style.color = ''; 
                    elStimulus.style.textShadow = ''; 
                    elStimulus.className = `color-${trial.color}`;
                    elStimulus.classList.remove('hidden'); 
                    this.state.trialStartTime = performance.now();
                    this.state.waitingForResponse = true;
                    this.state.timeoutIds.push(setTimeout(() => {
                        if (this.state.waitingForResponse) this.handleResponse('TIMEOUT');
                    }, this.config.timing.maxStimulus));
                }, this.config.timing.fixation));
            },

            handleInput(e) {
                if (!this.state.waitingForResponse) return;
                const key = e.key.toLowerCase();
                const color = this.config.keys[key];
                if (color) {
                    this.handleResponse(color);
                }
            },

            handleResponse(response) {
                if (!this.state.waitingForResponse) return;
                const rt = performance.now() - this.state.trialStartTime;
                this.state.waitingForResponse = false;
                this.state.timeoutIds.forEach(clearTimeout);
                this.state.timeoutIds = [];
                const trial = this.state.trials[this.state.trialIndex];
                
                const isCorrect = response === trial.color;
                
                this.state.results.push({ subjectId: App.subjectId, ...trial, response, rt: rt.toFixed(0), accuracy: isCorrect ? 1 : 0, timestamp: new Date().toISOString() });
                
                document.getElementById('stimulus').classList.add('hidden');
                
                // --- FEEDBACK LOGIC ---
                if (this.state.block === 'practice') {
                    // Practice Block: Show Text Feedback
                    const fbEl = document.getElementById('feedback-text');
                    
                    if (response === 'TIMEOUT') {
                        // REQ 4: NO FEEDBACK ON TIMEOUT
                        // Just wait the feedback duration before next trial
                        setTimeout(() => { 
                            this.state.trialIndex++; 
                            this.runTrial(); 
                        }, this.config.timing.feedbackDuration);
                        return; // Exit early to avoid showing text
                    } 
                    
                    // Standard Feedback for Key Press
                    fbEl.textContent = isCorrect ? "DOĞRU" : "YANLIŞ";
                    fbEl.className = isCorrect ? "feedback-correct" : "feedback-wrong";
                    
                    fbEl.classList.remove('hidden');

                    setTimeout(() => { 
                        fbEl.classList.add('hidden');
                        this.state.trialIndex++; 
                        this.runTrial(); 
                    }, this.config.timing.feedbackDuration);
                    
                } else {
                    // Experimental Block: No Feedback, just wait ISI
                    setTimeout(() => { 
                        this.state.trialIndex++; 
                        this.runTrial(); 
                    }, this.config.timing.isi);
                }
            },

            finish() {
                // 1. Calculate Statistics for Google Sheet (Background Only)
                const expResults = this.state.results.filter(r => r.block === 'experimental');
                const correct = expResults.filter(r => r.accuracy === 1);
                
                const accuracy = ((correct.length / this.config.trials.experimental) * 100).toFixed(1);
                const avgRT = (correct.reduce((s, r) => s + parseFloat(r.rt), 0) / correct.length || 0).toFixed(0);
                
                const congruent = correct.filter(r => r.condition === 'congruent');
                const incongruent = correct.filter(r => r.condition === 'incongruent');
                
                const congruentRT = congruent.length > 0 ? (congruent.reduce((s, r) => s + parseFloat(r.rt), 0) / congruent.length).toFixed(0) : 0;
                const incongruentRT = incongruent.length > 0 ? (incongruent.reduce((s, r) => s + parseFloat(r.rt), 0) / incongruent.length).toFixed(0) : 0;
                
                const stroopEffect = (parseFloat(incongruentRT) - parseFloat(congruentRT)).toFixed(0);

                // 2. Prepare Payload for Google
                const payload = {
                    subjectId: App.subjectId,
                    summary: {
                        accuracy: accuracy + '%',
                        avgRT: avgRT,
                        congruentRT: congruentRT,
                        incongruentRT: incongruentRT,
                        effect: stroopEffect
                    },
                    allTrials: this.state.results
                };

                // 3. Render Results Screen
                const html = `
                    <div class="result-icon-container">
                        <div id="secret-checkmark" class="checkmark-circle">
                            <svg class="checkmark-svg" viewBox="0 0 24 24">
                                <path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z"/>
                            </svg>
                        </div>
                    </div>
                    <div class="result-message-title">Oyun Başarıyla Tamamlandı</div>
                    <div class="result-message-sub">Katılımınız için teşekkür ederiz.</div>
                `;
                App.showResults(this.state.results, html);

                // --- SECRET TRIPLE CLICK LISTENER ---
                // We attach this AFTER App.showResults puts the HTML into the DOM
                const checkmark = document.getElementById('secret-checkmark');
                if(checkmark) {
                    checkmark.addEventListener('click', (e) => {
                        // e.detail counts the number of clicks in a short duration
                        if (e.detail === 3) {
                            Utils.downloadJSON(this.state.results, `stroop_BACKUP_${App.subjectId}.json`);
                            alert("Yedek JSON dosyası indirildi.");
                        }
                    });
                }

                // 4. Auto-Send Data
                App.sendToGoogle(payload);
                
                // 5. Update the button to allow manual retry if needed
                const btn = document.getElementById('btn-download');
                btn.onclick = () => App.sendToGoogle(payload);
            }
        };

        const initAudio = () => {
            SoundManager.init();
            document.removeEventListener('click', initAudio);
            document.removeEventListener('touchstart', initAudio);
        };
        document.addEventListener('click', initAudio);
        document.addEventListener('touchstart', initAudio);

        App.init();
    </script>
</body>

</html>
